=============================================================
====	.NET Framework, ASP.NET & MVC History
=============================================================

Note: Framework and ASP.NET version numbers are the same.

[year] [Framework/CLR] [Visual Studio (internal/file version]

2002, .Net 1.0/1.0, Visual Studio.NET (7.0/7.0)

		Web Forms (*.aspx)
		Web Services (*.asmx)

2003, .Net 1.1/1.1, Visual Studio.NET 2003 (7.1/8.0)

2005, .Net 2.0/2.0, Visual Studio 2005 (8.0/9.0)

		Master pages
		Web parts
		64-bit support
		Roles & Membership

2006, .Net 3.0/2.0, (no new Visual Studio release) 

		WPF
		WF
		WCF

2007, .Net 3.5/2.0, Visual Studio 2008 (9.0/10.0)

		AJAX
		LINQ
		EF1 (v1)
		Url Routing (in System.Web.Routing.dll)
			UrlRoutingModule
			RouteTable
			Route
			etc.

		MVC1 (2009):
			WebForms
			Html Helpers
			Ajax Helpers

		MVC2 (2009):
			Strongly-typed helpers
			client-side validation
			Areas
			support for data annotations
			HttpGet, HttpPost, etc attributes

2010, .Net 4.0/4.0, Visual Studio 2010 (10.0/11.0)

		EF4 (v2)
		WebPages
		Razor
		WebMatrix (2011)
		SimpleMembership (2011)
		Url Routing moved into System.Web.dll


		MVC3 (2011):
			ViewBag (ViewData that uses new dynamic ExpandoObject)
			Global Action Filters
			Unobtrusive JavaScript
			NuGet

2012, .Net 4.5/4.0, Visual Studio 2012 (11.0/12.0)

		EF5 (v3)
		WebPages2 (open sourced)
		WebAPI (open sourced)

		MVC4 (open sourced):
			Bundling & Minification

2013, .Net 4.5.1/4.0, Visual Studio 2013 (12.0/12.0)

		EF6 (open sourced)
		WebAPI2
		Identity 1.0
		Identity 2.0 (2014)
		
		MVC5:
			Attribute Routing
			Scaffolding
			Authentication Filters

2015, .Net 4.6/4.0, Visual Studio 2015 (14.0/12.0)

2016?, 5.0/.NET Core, Visual Studio "15" (15.0/?)

		EF7
		MVC6
		Razor 4

=============================================================
====	IIS and IIS Express Configuration
=============================================================

Visual Studio 2015 can be configured to use either the developer version of IIS,
IIS Express, or a local instance of IIS.

Configuration always starts here:

		C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\machine.config
		C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config

Next, if using IIS Express:

		{solution}\.vs\config\applicationhost.config
		{solution}\{application}\{application}.csproj

Or, IIS7:

		C:\Windows\System32\inetsrv\config\applicationHost.config


Note: IIS 7  no longer uses the "metabase" to store its configuration information,
instead it uses the above XML file. When you make changes to your application 
(such as adding or removing mappings) in the IIS management tool, they'll be 
stored in your application's web.config.

Finally, of course:

		{solution}\{application}\web.config


For example, if trying to use Windows Authentication with IIS Express, you'll
need to modify the following entry in applicationhost.config:

		<windowsAuthentication enabled="false">
			<providers>
				<add value="Negotiate" />
				<add value="NTLM" />
			</providers>
		</windowsAuthentication>

Also, be aware that Visual Studio wants to manage some of these IIS Express
properties for you. To see these properties, select the project in the solution
explorer and hit F4 (these are in the *.csproj):

		Anonymous Authentication
		Windows Authentication
		SSL Enabled
		PipeLine Mode (Integrated, Classic)
		etc.
		
To use IIS with Visual Studio, ensure you have access to the following folder:

		C:\Windows\System32\inetsrv\config

		And check:

				ISAPI & CGI Restrictions
				Folder permissions
				Application Pool
				Port
				Verify Web Site is running

Note: Visual Studio installs the "PageInspector" assembly in your machine's 
web.config here:

		C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config

This thing can do some screwy things to your ASP.NET Lifecycle (loading, unloading
assemblies, calling Application_Start multiple times, etc.)

Remove it like this if you want:

		<system.web>
			<compilation>
				<assemblies>
					<remove assembly="Microsoft.VisualStudio.Web.PageInspector.Loader, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
				</assemblies>
			</compilation>
		</system.web>

=============================================================
====	IIS Architecture and IIS Authentication
=============================================================

ASP.NET is implemented as an IIS ISAPI Extension (aspnet_isapi.dll). The IIS 
process and extensions of course must run under some security context 
(user account), IIS allow each request to run with an associated access token.
By default, all resource requests (HTML files, etc) will be compared to this
token to determine if the user making the request can access the resource.

IIS creates this access token based on the IIS authentication options, which include:

		Basic Authentication per RFC 2617
		Integrated Windows Authentication (enabled by default)
		Annonymous Authentication (also enabled by default)

These are implemented on the IIS as native Http Modules such as:

		C:\Windows\System32\inetsrv\authsspi.dll
		C:\Windows\System32\inetsrv\authbas.dll
		C:\Windows\System32\inetsrv\authanon.dll

With Basic or Windows, IIS will challenge the web browser for credentials. 

With Anonymous, a predefined, existing account will be used for the request. Any of these 
accounts may or may not have access to the actual resource (file).

How this works (and IIS architecture) has changed over the years:

In II5 (and IIS 5 Isolation Mode in II6), IIS (inetinfo.exe) ran in user mode under SYSTEM,
and ASP.NET ran in a single worker process (aspnet_wp.exe) under the ASPNET account. The 
access token for anonymous access was IUSR_MachineName (using the NETBIOS name), but could
be changed.

In IIS6, IIS was moved to kernel mode (HTTP.sys) and ASP.NET work processes (w3wp.exe) run
in "application pools". The access token for anonymous access was still IUSR_MachineName.
IIS6 was the first version of IIS after the .NET Framework was released.

In IIS7, the anonymous account was changed to the built-in IUSR, and optionally can be a
new concept called ApplicationPoolIdentity. Also, ASP.NET has been fully integrated into
IIS, and the ISAPI extension is no longer used (unless you are in "Classic mode").

Note: IIS7 Integrated Mode does not support ASP Impersonation (see below).

VERSION		IIS Process/Account		ASP.NET Worker Process/Account	IIS Anonymous Account
-------		--------------------	------------------------------	-----------------------
5/2000		inetinfo.exe/SYSTEM		aspnet_wp.exe/ASPNET			IUSR_MachineName
6/2003		(kernel)				w3wp.exe/NETWORKSERVICE			IUSR_MachineName
7/2008		(kernel)				w3wp.exe/ApplicationPoolId		IUSR
8/2012		..						..								..
10/2016		..						..								..

You can access the account that is actually executing the code this way:

		System.Security.Principal.WindowsIdentity.GetCurrent().Name

This will either be the Worker Process Account or something else if impersonation is enabled.

You can see the account in the "access token" that IIS sends to ASP.NET this way:

		Request.LogonUserIdentity

This will either be the authenticated user (basic or windows) or the anonymous user (IUSR),
and is always a WindowsIdentity principal (NOT an IPrincipal - see ASP.NET Authentication).

Note: Microsoft plans to further decouple ASP.NET from IIS via the "Open Web Interface for 
.NET" (OWIN) standard and project Katana.


=============================================================
====	ASP.NET Impersonation & Delegation
=============================================================

Normally ASP.NET applications execute using the security context of the worker process. This is
not to be confused with the IIS-authenticated user (the access token).

If desired, the application can be configured to run in the security context of the requesting
user, or a completely different user:

	<system.web>
		<identity impersonate="true" userName="domain\user" password="password" />

Note: impersonation is not supported in II7 Integrated mode, but it is supported in Classic mode.

Note: a related but distinct concept is delegation. This is where IIS bounces the
user credentials against another server. NTLM doesn't support it, but Kerberos
and Basic do support it. You can always call LogonUser with "Interactive."



=============================================================
====	Framework 4.5 Runtime Opt-In
=============================================================

Some of the information below (mostly regarding security) involves breaking changes
to the Framework runtime between version 4.0 and 4.5. Both use CLR 4.0, so the
breaking changes are in "Framework code" only.

When an ASP.NET application includes the following in the web.config:

		<httpRuntime targetFramework="4.5" />

or a non-web application includes this in its app.config:

		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5"/>

Then you use the new runtime. Otherwise you will run in "quirks mode" and be compatible
with the 4.0 Framework.

Note when you turn on 4.5 in an ASP.NET application the following is infered (but
overrideable) in your web.config:

		<configuration>
		  <appSettings>
			<add key="aspnet:UseTaskFriendlySynchronizationContext" value="true" />
			<add key="ValidationSettings:UnobtrusiveValidationMode" value="WebForms" />
		  </appSettings>
			<system.web>
			  <compilation targetFramework="4.5" />
			  <machineKey compatibilityMode="Framework45" />
			  <pages controlRenderingCompatibilityVersion="4.5" />
			</system.web>
		</configuration>

It's a mess.


=============================================================
====	ASP.NET Security
=============================================================

ASP.NET provides cryptographic services to applications, for example encrypting 
"ViewState" or "Authentication Tickets".

Cryptographic settings can be changed with the <machineKey> element in web.config:

		<system.web>
			<machineKey decryption="DES" ... />

Controlling ViewState:

		<system.web>
			<pages viewStateEncryptionMode="Always" ... />

Controlling Authentication Tickets:

		<system.web>
			<forms protection="All" ... />

IIS5 ran under the SYSTEM account, and machine keys were stored in as LSA Secrets:

		HKEY_LOCAL_MACHINE\SECURITY\Policy\Secrets

In IIS6, this was changed to NETWORKSERVICE and the HKCU hive:

		HKEY_CURRENT_USER\Software\Microsoft\ASP.NET\4.0.30319.0

Before .NET 4.0, developers didn't have direct access to these functions. The
following classes are marked internal:

		System.Web.Configuration.MachineKeySection.Encode()
		System.Web.Configuration.MachineKeySection.Decode()

However, in 4.0 the MachineKey class was added, providing access to these methods:

		System.Web.Security.MachineKey.Encode()
		System.Web.Security.MachineKey.Decode()

In 4.5 (see the opt-in section above) support for the newer CryptoAPI was added to
ASP.NET:

		System.Web.Security.Cryptography.AspNetCryptoServiceProvider.Protect()
		System.Web.Security.Cryptography.AspNetCryptoServiceProvider.UnProtect()

Again, these are internal, but you can access the functionality via MachineKey:

		System.Web.Security.MachineKey.Protect()
		System.Web.Security.MachineKey.UnProtect()


=============================================================
====	.NET (and ASP.NET) Authentication & IIS
=============================================================

ASP.NET provides an additional authentication layer that build upon .NET security 
features found in the System.Security namespace. These are implemented in managed
HttpModules that handle the HttpApplication's AuthenticateRequest event (see "Application
Lifecyle" below), such as:

		DefaultAuthenticationModule
		WindowsAuthenticationModule
		FormsAuthenticationModule
		
There is also a mechanism to track anonymous users via cookies:

		AnonymousIdentificationModule

At this layer, we can set the current authenticated user for the current request 
(and thread) using the following properties:

		System.Threading.Thread.CurrentPrincipal
		System.Web.HttpContext.User

Both of which are of type IPrincipal (NOT necessarily WindowsPrincipal, as sent over by IIS). 
Typically these are GenericPrincipal objects, and the DefaultAuthenticationModule will create 
a Principal whether there is an authenticated user or not.

Unfortunately, these are redundant, and both should point to the same principal and should
be kept in sync. When setting them in custom authentication schemes, both should be set
at the same time. The threading version is what you use in non-ASP applications, and the
HttpContext version is supposed to be "convienent".

There's a lot of strange redundencies in ASP.NET, for example, these always return the 
same value:

		Context.Request.IsAuthenticated 
		Context.User.Identity.IsAuthenticated

The IPrincipal interface is very simple, and basically combines an "identity" with a
generic concepts of authentication and authorization ("roles").

		IPrincipal:
			IIdentity Identity {get;}
			bool IsInRole(string);

		IIdentity
			string AuthenticationType {get;} //NTLM, Basic, etc.
			bool IsAuthenticated {get;}
			string Name {get;}

You can use the PrincipalPermission attribute to mark classes and methods as requiring
authenticated users with specific roles before allowing execution. Understand this is 
a .NET feature, not a ASP.NET-specific feature.

Note: be aware that with the new Identity mechanism added in ASP.NET 4.5, the inheritance
hierarchy for many classes (GenericPrincipal, FormsIdentity, etc.) has been changed to 
include new classes that provice the "claims based" Identity features:

		Claim
		ClaimsPrincipal
		ClaimsIdentity
		ClaimsPrincipalPermission

If not using claims, you can ignore these and use the old interfaces and classes. As of
.NET 4.5, instead of implementing IPrincipal and IIdentity (as in custom Forms Authentication), 
one should derive from these classes. Instead of custom properties (email, location), use claims.

We use the following web.config entry to configure ASP.NET Authentication:

		<system.web>
			<authentication mode= "[Windows|Forms|Passport|None]"/>

ASP.NET "Windows" Authentication will take the access token from IIS (only if IIS Authentication
Windows or Basic is enabled) and set various properties of the GenericPrincipal to values in the 
token. This is implemented in the WindowsAuthenticationModule (an HttpModule). It is important to 
understand that IIS actually does the authentication and this module simply populates the principal. 

"Forms" enables the "Forms Authentication" mechanism where the application can define its own
custom users and roles (stored in a database, for example). We'll discuss this next.

"None" does nothing, and again allows the application to set the IPrincipal in a custom manner.

You can turn on anonymous user tracking like this:

		<system.web>
			<anonymousIdentification enabled="true" />

Note: Also see LOGON_USER and AUTH_TYPE.

=============================================================
====	Using Declarative Security
=============================================================

You can control access to code using the IPrincipal object via attributes such as:

		[PrincipalPermission(SecurityAction.Demand, Authenticated = true)]
		public class Something
		{
		}

=============================================================
====	ASP.NET Application & Request Lifecycle
=============================================================

In IIS7, ASP.NET runs in two modes:
		
		Classic (IIS5/6 mode)
		Integrated

When a request comes into IIS7 Classic Pipeline (or IIS5/IIS6), the extension of 
the reqested file is matched to a "Script Map" which routes the request to native
ISAPI extensions. In the case of ASP.NET file types (*.aspx, *.cshtml) these requests 
go to the aspnet_isapi.dll extension.

In IIS7 Integrated mode, all requests go through a "unified pipeline" where they can
be handled by either native or managed handlers and modules. ASP.NET is built into
IIS7.

The first request to either pipeline creates the following object graph:

		ApplicationManager
			AppDomain
				HostingEnvironment 
				HttpRuntime
					(pool of HttpApplication objects)
						app1 - HttpContext
									HttpApplication
									HttpRequest
									HttpResponse
									HttpApplicationState
									HttpSessionState
						app2 - HttpContext
									HttpApplication
									HttpRequest
									HttpResponse
									HttpApplicationState
									HttpSessionState

Note: Since there are many HttpApplication objects in the pool, Init() methods on both
the application and on each module can be called multiple times. 

Each HttpApplication and corresponding HttpContext object int the pool will serve one
request on one thread.

If you have a Global.asax defined in your application, the runtime will create 
instances of that for the application object (Global.asax is derive from 
HttpApplication). HttpApplication defines several events (discussed below), but
it is important to understand that there are several additional "psuedo events"
that you can handle in Global.asax that are not part of the HttpApplication
class:

		Application_Start
		Session_End
		Application_End

As we'll see next, these events are fired outside of the context of a request,
such as when the first request is served after the application is loaded.

Classic Pipeline Lifecyle:

	1] HttpApplication.Application_Start() is called once per lifetime
	2] HttpModules are created for each application object in the pool
	3] HttpModules are initialized: IHttpModule.Init()
	4] HttpApplication.Init() is called for each application object in the pool

Classic Pipeline Code Path:

	System.Web.Hosting.ISAPIRuntime.ProcessRequest()
	...
		HttpApplicationFactory.GetApplicationInstance()
			HttpApplicationFactory.EnsureAppStartCalled()
				Application_Start() - global.asax psuedo event
			HttpApplicationFactory.GetNormalApplicationInstance()
				HttpApplication.InitInternal()
					HttpApplication.InitModules()
						foreach (module){ HttpModule.ctor() }
						HttpApplication.InitModulesCommon()
							foreach (module){ HttpModule.Init() }
					HttpApplication.HookupEventHandlersForApplicationAndModules()
					HttpApplication.Init() 


Integrated Pipeline Lifecyle:

	1] HttpApplication.Application_Start() is called once per lifetime
	2] HttpModules are created for each application object in the pool
	3] HttpApplication.Init() is called for each application object in the pool
	4] HttpModules are initialized: IHttpModule.Init()

Integrated Pipeline Code Path:

	System.Web.Hosting.PipelineRuntime.InitializeApplication()
		System.Web.HttpApplicationFactory.GetPipelineApplicationInstance()
			HttpApplicationFactory.GetSpecialApplicationInstance
				HttpApplication.InitSpecial()
					HttpApplication.RegisterEventSubscriptionsWithIIS()
						HttpApplicationFactory.GetModuleCollection()
							foreach (module){ HttpModule.ctor() }
						HttpApplication.HookupEventHandlersForApplicationAndModules()
						HttpApplicationFactory.EnsureAppStartCalledForIntegratedMode()
							Application_Start() - global.asax psuedo event 
						HttpApplication.Init() 
						foreach (module){ HttpModule.Init() }


Note: the classic and integrated pipelines swap the order of the HttpModules Init() and 
the HttpApplication Init(). This is a "breaking change" for the Integrated Pipeline.

HttpModule Lifecyle:

		Init()
		(handle requests via HttpApplication events)
		Dispose()

Note: The Dispose() method of the IHttpModule interface is NOT part of the "Dispose
Pattern", i.e. IDisposable. Rather it is called when the HttpApplication is destroyed
by the HttpRuntime (whenever that may be). Here is the code path:

		HttpRuntime.Dispose()
			HttpApplicationFactory.Dispose()
				HttpApplicationFactory.DisposeHttpApplicationInstances()
					HttpApplication.DisposeInternal()
						HttpModule.Dispose()

Note: HttpModules are processed in the order they are registered.

As each request is serviced, various HttpApplication events are raised, such as:

		BeginRequest
		AuthenticateRequest
		AuthorizeRequest
		ResolveRequestCache
		PostResolveRequestCache
			(find the HttpHandler for this extension at this point)
			(some handlers may invoke a BuildProvider e.g. Razor Web Pages)
		ProcessRequest
		EndRequest

IIS7 Integrated Mode adds the follwing new events:

		 MapRequestHandler
		 LogRequest
		 PostLogRequest 

HttpModules can handle these events to modify the request pipeline behavior, for
example, a module could call HttpContext.RemapHandler() in PostResolveRequestCache
to dynamically serve content.

Global.asax can handle these events too:

		Application_BeginRequest
		Application_AuthenticateRequest
		Application_AuthorizeRequest
		Application_ProcessRequest
		Application_EndRequest

Note: for backwards compatibility with ASP (classic ASP, not .NET), you can use
an alternate signature:

		Application_OnStart
		Application_OnBeginRequest
		Application_OnEnd
		etc

TODO: Do application-level events fire after modules-level events? It seems so.

HttpModules may raise events as well. Global.asax can handle these using similar
signature syntax:

		{friendlyname}_{eventname}

Where "friendlyname" is the "name" attribute in the web.config:

		<httpModules>
			<add type="com.paralib.SomeVeryCoolModule, paralib" name="Cool" />
		</httpModules>

Would look like this in global.asax:

		protected void Cool_EventName(object sender, EventArgs e)
        {
        }


Note: this will not work with DynamicModules! Currently the DynamicModuleHelper class
(in Microsoft.Web.Infrastructure) creates friendlynames like this:

		"__DynamicModule_com.paralib.SomeVeryCoolModule,paralib, Version=1.0.0.0, Culture=neutral, 
		PublicKeyToken=null_1586a9a1-695a-4da0-8ca4-9f4a19e75b6e""

Which are not very friendly and will not "autowire" in global.asax.

You could do the following in your HttpApplication.Init() method:
 
            var module = (com.paralib.SomeVeryCoolModule)this.Modules[
							"__DynamicModule_com.paralib.SomeVeryCoolModule, 
							paralib-, Version=1.0.0.0, Culture=neutral, 
							PublicKeyToken=null_1586a9a1-695a-4da0-8ca4-9f4a19e75b6e"];

            module.EventName += Module_EventName;

But that is ridiculous.

Note: The session events are a bit strange. Session_Start is raised by the 
SessionStateModule (friendlyname="Session"), but Session_End is actually a psuedo event 
that is fired by the HttpApplicationFactory in response to a signal from the SessionState class.

Note: Visual Studio can't debug application start up in IIS, as it attaches after most of this
stuff happens. However, you can do this in IIS Express.


=============================================================
====	Build Providers 
=============================================================

(TODO later)



=============================================================
====	Zero Configuration of HttpModules & BuildProviders
=============================================================

TODO
TODO
TODO
 rework
TODO
TODO
TODO


Since Web Pages are implemented as HttpModules you may expect to see registration 
entries in your Web.config files like this:

		<configuration>
		  <system.web>
			<httpModules>
			  <add name="HelloWorldModule" type="HelloWorldModule"/>
			 </httpModules>
		  </system.web>
		</configuration>

Or because Razor uses BuildProviders, something like this:

		<compilation debug=”false”>
		 <buildProviders>
		  <remove extension=”.xsd”/>
		  <add appliesTo=”Code” extension=”.xsd” type=”Msdn.Samples.Compilation.XsdClassBuildProvider”/>
		 </buildProviders>
		</compilation>
 
However, in ASP.NET 4 the PreApplicationStartMethodAttribute (System.Web.dll) was added, 
allowing for zero-config ASP.NET applications. This attribute is used at the assembly 
level and allows startup code to run before Application_Start. 

Used with the DynamicModuleUtility class (Microsoft.Web.Infrastructure.dll), assemblies 
such as System.Web.WebPages.dll can register thier HttpModule as soon as they are loaded.

The Razor BuildProviders for VB (*.vbhtml) and C# (*.cshtml) are installed by default for
MVC applications. This is also accomplished via the PreApplicationStartMethod attribute
(in System.Web.WebPages.Razor.dll), so when that assembly is loaded, so is Razor.

The Razor build providers are registered using the System.Web.Compilation.BuildProvider 
class like this:

		BuildProvider.RegisterBuildProvider(".cshtml", typeof(RazorBuildProvider));
		BuildProvider.RegisterBuildProvider(".vbhtml", typeof(RazorBuildProvider));

You can also dynamically add a referenced assembly (as you would in the <assemblies> 
section of web.config) with:

		System.Web.Compilation.BuildManager.AddReferencedAssembly()


=============================================================
====	Configuring HttpHandlers
=============================================================

The ASP.NET Pipeline will not be invoked unless a file extension matches
a mapped HttpHandler.


httphandlers are searched in the order they are registered

IIS6 workarounds for extensionless mapping:
		runAllManagedModulesForAllRequests  (RAMMFAR)
		*.* mappings
		*.mvc mappings
		aspnet_filter.dll that appends “/eurl.axd/GUID"



TODO
TODO

IIS7 Classic:

	script map extension to isapi & managed handler
	script map extension to isapi & routehandler + remap


IIS7 Integrated:

	managed handler
	"*." -> TransferRequestHandler & routehandler + remap
	"*.cshtml" -> HttpForbiddenHandler & routehandler +remap

preconditions for integrated/classic, 32/64





TODO
TODO
TODO
TODO

In classic mode, a "Script Map" must be registered for the file extension to be handled. When
these files are requested, they will go through the ASP.NET pipeline.


=============================================================
====	ASP.NET Routing 
=============================================================


TODO
TODO
TODO

httphandlers in the past only worked for files with extensions

extensionless handler (and ii6 workaround)

by default routing is bypassed for existing files

routing existing files:

		RouteTable.Routes.RouteExistingFiles = true;
        RouteTable.Routes.Add("foo route",new Route("{filename}.foo", new Foo()));

		or use any old stupid handler to get the pipeline running

		IRouteHandler

TODO
TODO
TODO


MVC builds upon ASP.NET (System.Web.dll) and extends ASP.NET Routing, which is 
implemented in the UrlRoutingModule class (an HttpModule). MVC uses ASP.NET
Routing to route requests to Controllers and Actions.







=============================================================
====	Forms Authentication & URL Authorization
=============================================================

A request has an "authenticated user" when there is a IPrincipal object in 
HttpContext (syncronized with Thread.CurrentPrincipal). This "authenticated"
user may be anonymous, if the user name is empty and/or IsAuthenticated returns
false.

By default, there are several key HttpModules we need to understand, that are executed
in the following order:

		WindowsAuthenticationModule
		FormsAuthenticationModule
		DefaultAuthenticationModule
		UrlAuthorizationModule

The Windows module is enabled by setting:

		<authentication mode="Windows">

If enabled, it tries to set the IPrinciple with the user from IIS during the AuthenticateRequest 
event. Otherwise it will use the Windows AnonymousIdentity or try to create it from the 
worker request.

The Forms module's AuthenticateRequest runs next. If not enabled, or it there is already a principal, 
it does nothing. It fires its own FormsAuthenticate event and if a handler creates a user then that 
will become the principal. Otherwise it will look for an ecrypted "ticket" (FormsAuthenticationTicket)
inside an "auth cookie", if there is no ticket (or if the ticket has expired), it does nothing.

If there is a ticket, then it "renews" the ticket and creates a GenericPrinciple with a FormsIdentity
using the information in the ticket, and saves the encrypted ticket back into the cookie.

Lastly, at this stage of the request, the forms module will look and see if the request is for the
login page (configured in the <authentication><forms> element), and set the HttpContext's SkipAuthorization
property to true.

Note: All encryption is done using the built-in ASP encryption and keys. See the section 
"ASP.NET Security" for more.

Next the DefaultAuthenticationModule's handler runs. This works differently depending on the mode.

In classic mode, this module hooks the HttpApplication's DefaultAuthentication event, which fires when
there is no authentication (no principal in HttpContext), which in turn fires the global.asax's
DefaultAuthentication_OnAuthenticate event. None of this is supported in integrated mode.

In integrated mode, the module hooks the PostAuthenticateRequest, and throws no event.

In either case, if the Http status is greater than 200, nothing. Otherwise, if there is no authenticated
user (prinical) then fire the event (classic mode only) and use the created user. If no user is
created, then creat a GenericPrinical with a GenericIdentity (anonymous).

Note: the DefaultAuthenticationModule module lives in "BackStopAuthentication.cs"

Next the UrlAuthorizationModule's AuthorizeRequest handler fires. If the HttpContext's SkipAuthorization
is set, nothing. Otherwize, the IPrincipal is checked against the access rules in the config file,
and if the user doesn't have access, the statas is set to 401 (unauthorized) and the pipeline jumps
to the EndRequest event (no handler is served).

The Windows and Default modules don't handle EndRequest, but Forms does. If not a 401, then nothing.
If the Response.SuppressFormsAuthenticationRedirect is set, nothing. Otherwise, send a 302 redirect
to the login page in the config file. When doing the redirect, we save the "ReturnUrl" so that the login
page can redirect to the original page on success. If the redirect or return also gets a 401, then 
pass that back to the browser so we don't loop infinitely. 

Note: Ajax calls generally want the 401 not the 302.

At this point, we either have the page we wanted to see or we are at the login page.

If the user has the proper credentials, the login page should:

		create a FormsAuthentication ticket with the user name (and optional user data)
		serialize the ticket
		encrypt it
		create a cookie using the cookie name in the config file and the encrypted ticket
		redirect the user to the originally requested page (ReturnUrl)

Note: there are helper methods in the FormsAuthentication class to do most of this, but these
steps can be done in user code as well.

You can replace the principal with a custom object (to support custom roles, ect) in either of these:

		Application_AuthenticateRequest
		Application_PostAuthenticateRequest

Make sure you set both:

		HttpContext.Current.User
		Thread.CurrentPrincipal

Logically, if you are setting the identity, favor AuthenticateRequest. If you are add roles or otherwise
setting up authorization, use PostAuthenticateRequest.


=============================================================
====	Membership & Identity Frameworks
=============================================================

Here we discuss the following frameworks:

		ASP.NET 2.0 Membership
		SimpleMembership
		ASP.NET Identity

In ASP.NET 2.0 Membership was introduced. This used the new Provider Model,
which is a dependency injection framework implementing the following patterns:

		Strategy
		Factory Method
		Singleton
		Fascade

Other things besides membership used the provider model, such as session storage.

Two built-in membership providers were:

		SQL Server
		Active Directory

Using membership, your application could get authentication, role-based
authorization, and management features "for free". Visual Studio made it "easy"
to build login, change password, and "create user" forms using membership-aware 
Web Form controls (*.ascx).

Membership was fundementally broken. The built-in providers were limited in such
things like table names and hashing algorithms, and the interfaces were heavy and 
painful to implement if you wanted to create your own provider. Also, Membership
was tied to Forms Authentication. The biggest issue that "roles" are not always
the best authorization model.

When the WebMatrix was released in 2001 (around the MVC3/MVC4 releases), a new
membership system (SimpleMembership) was released along with a new WebSecurity
API. While these originally came with WebMatrix, they could be used in MVC.
Unfortunately, SimpleMembership basically wrapped the ASP.NET 2.0 Membership
classes with "simpler" ones:

		SimpleMembershipProvider
		SimpleRoleProvider

A few improvements were made but SimpleMembership essentially has all the same
issues as ASP.NET Membership.

In 2013 ASP.NET Identity was released. It is a complete redesign and rewrite of the
membership system. In 2014 Identity 2.0 was released.

Some ASP.NET Identity 1.0 Features:

		OWIN Support
		External Logins (Facebook, Google, etc.)
		Async Support
		EF6-based provider

Some ASP.NET Identity 2.0 Features:

		Two-Factor Authentication
		Account Confirmation via email
		Account Lock-Out

In short, Identity is better than "classic" Membership, but it's new and in a 
state of change, and still pretty heavy. 



=============================================================
====	ASP.NET Web Forms vs Web Pages (and Razor)
=============================================================

TODO
TODO
TODO

 rework

 WebPagesDeployment & version

	   <appSettings>
		<add key="webpages:Enabled" value="false" />
	  </appSettings>

"*.cshtml" -> HttpForbiddenHandler & routehandler +remap


WebPageHttpModule
	PostResolveCache
		Remap


WebPageRoute

BuildManagerWrapper

TODO
TODO
TODO

Web Forms (*.aspx and *ascx files) are the original ASP.NET HTML rendering mechanism,
replacing the classic ASP paradigm (similar to but predating the similar PHP and JSP).

Web Forms are built into System.Web.dll and Visual Studio provides drag-and-drop designers
that make web development much like using any other RAD tool. They are event-driven 
and component-based, so it is not very different (from the developers point of view)
from developing a desktop application. Web Forms are heavy-ish, have a steep learning 
curve, as well as several limitations such as being limited to a single (server-side)
<form> tag.

In ASP.NET 2.0, support for "BuildProviders" that allow for custom compilation of files
in the ASP.NET framework (*.wsdl and *.xsd files are a good example).

ASP.NET Web Pages (System.Web.WebPages.dll) are a new technology that leverages the
build provider mechanism to simplify the Web Form model, and allows for different 
templating languages (such as Razor) to be used in ASP.NET. Web Pages debuted with MVC3 
and the WebMatrix IDE, but is a distinct technology and now used in MVC. 

Web Pages handles Web Page requests via the WebPageHttpModule and WebPageHttpHandler 
classes, and registers BuildProviders so that Razor view can be compiled at runtime, 
upon the first request.

In MVC, you can force views to be compiled at build by adding this to the *.csproj:

		<MvcBuildViews>true</MvcBuildViews>

But that doesn't actually pre-compile the views and they will still be compiled at
runtime. To do that, see the following NuGet packages:

		RazorGenerator.Mvc
		RazorGenerator.MsBuild

Web Pages are very similiar to classic ASP in that it is a very simple and lightweight 
templating engine. The main differences are that Web Pages are compiled and can use the
full .NET CLR.

Note on Razor: It is important to understand that while Razor is designed to be an HTML
templating engine (it understands HTML <tag> syntax), and it is located in the "System.Web"
namespace (System.Web.Razor.dll), Razor actually has no dependencies on ASP.NET. Razor can
be used completely independently of MVC or ASP.NET.

Certain constructs (@Html, Layouts & @RenderSection, etc.) are actually part of MVC base
view classes and technically not Razor or Web Pages.






=============================================================
====	MVC Overview
=============================================================

The current version of MVC (as of this writing) is 5.2, and it is based on ASP.NET 4.6.

MVC lives in System.Web.Mvc.dll, and works primarily by leveraging and extending ASP.NET's
built-in Routing, Web Forms, and Web Pages features.

For example, ASP.NET Routing is enhanced by several extension methods to the RouteCollection
class (see System.Web.Mvc.RouteCollectionExtensions). These methods route URLs to Controllers
and Actions.

When a view needs to be rendered, MVC relies on ViewEngines to find the appropriate view
and render it. ViewEngines implement the IViewEngine interface.

By default, two ViewEngines are registered:

		WebFormViewEngine
		RazorViewEngine

The "standard" MVC view locations are hard-coded in these view engines. These are the default
locations searched when looking for views:

		~/Views/Hello/Index.aspx
		~/Views/Hello/Index.ascx
		~/Views/Shared/Index.aspx
		~/Views/Shared/Index.ascx
		~/Views/Hello/Index.cshtml
		~/Views/Hello/Index.vbhtml
		~/Views/Shared/Index.cshtml
		~/Views/Shared/Index.vbhtml

The job of the ViewEngine is to locate a view (and object that implements IView) so that it
can be rendered. How it is rendered depends on the underlying view technology. For example,
The WebFormViewEngine expects views to derive from ViewPage, which in turn derives from the 
regular ASP.NET Page class. The RazorViewEngine expects its views to be WebViewPages, which
derive from WebPageBase (a class in System.Web.WebPages.dll).

If the view needs to be compiled, the registered BuildProvider will do that on the first
request.

In this manner MVC jumps the gap between the MVC-world and the WebForm-world (or
WebPage-world).

These are the relevant class hierarchies:

	Web Forms (Razor):

		System.Web.Mvc.VirtualPathProviderViewEngine:IViewEngine
			System.Web.Mvc.BuildManagerViewEngine
				System.Web.Mvc.WebFormViewEngine

		System.Web.UI.Page
			System.Web.Mvc.ViewPage
				System.Web.Mvc.ViewPage<T>

	Web Pages (Razor):

		System.Web.Mvc.VirtualPathProviderViewEngine:IViewEngine
			System.Web.Mvc.BuildManagerViewEngine
				System.Web.Mvc.RazorViewEngine
	
		System.Web.WebPages.WebPageBase
			System.Web.Mvc.WebViewPage
				System.Web.Mvc.WebViewPage<T>


Both Web Form and Razor views have access to MVC-centric properties and methods such
as @Html and @ViewBag, but these are not part Web Forms or Web Pages or Razor. These
members are simply implemented in the base classes for view (ViewPage or WebViewPage).
Therefore, regardless of which of the two built-in view technologies you are using, 
all of MVC idioms are supported and avaliable.




=============================================================
====	Creating an MVC5 Project (the hard way)
=============================================================

The built-in MVC5 templates are very heavy, and include things like ASP.NET
Identity and generally make a mess of things. We don't use the built-in
templates.

Create new project:

		Framework 4.6
		ASP.NET Web Application
		Empty 4.6 Template
		Uncheck "Host in the cloud"

Add Microsoft.AspNet.Mvc 5 via NuGet (or do it manually - see below)

Create a global event handler (Global.asax)

IIS usually has several HttpHandlers installed to process "resources", such as
scripts and other data embedded into assemblies. These handlers are registered
in the IIS (or IIS Express) Web.configs like this:

		<configuration>
			<system.web>
				<httpHandlers>
					<add path="WebResource.axd" verb="GET" 
					type="System.Web.Handlers.AssemblyResourceLoader" 
					validate="True" />
				</httpHandlers>
			</system.web>
		</configuration>

We don't want these paths getting routed to controllers by accident, so all 
MVC applications will have the following instruction in Application_Start:

		RouteTable.Routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

Create a controller. The containing folder name doesn't matter, but the class
should derive from Controller and the class name must end in "Controller".
We use attribute-based routing.

Configure attribute-based routing in the application start event. We don't 
use the older MapRoute-based configuration in our projects.

Create a "Views" folder (following the ViewEngine conventions), and add a Web.config 
file to configure razor and prevent *.cshtml and other files from being served or
executed when accessed directly (remember that when a file path exists, it isn't routed).
In other words, stuff in the views folder should only be accessible via routes and the 
view engine, not http://localhost/Views.

Add a view. Visual Studio 2015 will only help you create Razor views these days, but 
if you want to create an *.aspx, create it manually and just make sure you change the 
base class to ViewPage:

		public partial class Index : System.Web.Mvc.ViewPage
		{
			.
			.
			.
		}

Add a model, pass it to the view in the controller. Optionally mark the view as 
strongly-typed. You can do this with *.aspx files as well, just use ViewPage<T>.

Use a layout.

Move the layout code to a _ViewStart file (note case of the word viewstart doesn't matter).

Done.


=============================================================
====	Manual Installation of MVC 5 (with Razor & Roslyn)
=============================================================

The MVC NuGet packages aren't magic, and it helps to understand how to create an MVC project
without using NuGet at all.

Install the "MVC 5.2.3" assembly:

		..\packages\Microsoft.AspNet.Mvc.5.2.3\lib\net45\System.Web.Mvc.dll

If you refrence older assemblies that bind against an older version of MVC, add this to 
web.config for backwards compatibility:

		<runtime>
			<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
				<dependentAssembly>
					<assemblyIdentity name="System.Web.Mvc" publicKeyToken="31bf3856ad364e35"/>
					<bindingRedirect oldVersion="1.0.0.0-5.2.3.0" newVersion="5.2.3.0"/>
				</dependentAssembly>
			</assemblyBinding>
		</runtime>


Install Razor 3.2.3 and related assemblies:

		..\packages\Microsoft.AspNet.Razor.3.2.3\lib\net45\System.Web.Razor.dll
		..\packages\Microsoft.AspNet.WebPages.3.2.3\lib\net45\System.Web.Helpers.dll
		..\packages\Microsoft.AspNet.WebPages.3.2.3\lib\net45\System.Web.WebPages.dll
		..\packages\Microsoft.AspNet.WebPages.3.2.3\lib\net45\System.Web.WebPages.Deployment.dll
		..\packages\Microsoft.AspNet.WebPages.3.2.3\lib\net45\System.Web.WebPages.Razor.dll
		..\packages\Microsoft.Web.Infrastructure.1.0.0.0\lib\net40\Microsoft.Web.Infrastructure.dll

Note: Not all of these are required at compile time - and at runtime they run from the GAC.

Again, for backwards compatibility of older assemblies:

		<runtime>
			<assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
			  <dependentAssembly>
				<assemblyIdentity name="System.Web.Helpers" publicKeyToken="31bf3856ad364e35"/>
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0"/>
			  </dependentAssembly>
			  <dependentAssembly>
				<assemblyIdentity name="System.Web.WebPages" publicKeyToken="31bf3856ad364e35"/>
				<bindingRedirect oldVersion="1.0.0.0-3.0.0.0" newVersion="3.0.0.0"/>
			  </dependentAssembly>
			</assemblyBinding>
		</runtime>


Install Roslyn 1.0.1:

If you want to use C# 6.0 features in your Razor views (and you do), then you'll have to install
the new Roslyn compiler service. Visual Studio 2015 and the 4.6 framework compiler uses the new
C# 6.0 features automatically, but these aren't used for Razor views. Instead, ASP.NET will use
the older CodeDomProvider (System.dll) to compile your views, and this doesn't support C# 6.0.

So if you want to use, say "string interpolation" (in a Razor view), you'll need to install
Roslyn:

		@($"this is foo: {foo}")

Unfortunately, this is pretty complicated to do manually, so you'll still want to use NuGet for
this. But we'll explain what the NuGet package actually does:

Install the NuGet package  "CodeDOM Providers for .NET Compiler" v1.0.1, which will add the
following reference to your project:

		..\packages\Microsoft.CodeDom.Providers.DotNetCompilerPlatform.1.0.1\
								lib\net45\Microsoft.CodeDom.Providers.DotNetCompilerPlatform.dll

The Roslyn package depends on the "Microsoft.Net.Compilers" 1.0.0 package, but only for the
toolchain (it doesn't add any references to the project).								
								
The installer will also add the following target to your *.csproj file:

		<Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
			...
		</Target>

Which will copy the csc.exe compiler to your output folder here:

		bin\roslyn

And add the following to your web.config:

		<system.codedom>
			<compilers>
				<compiler language="c#;cs;csharp" extension=".cs"
				type="Microsoft.CodeDom.Providers.DotNetCompilerPlatform.CSharpCodeProvider, Microsoft.CodeDom.Providers.DotNetCompilerPlatform, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
				warningLevel="4" compilerOptions="/langversion:6 /nowarn:1659;1699;1701"/>
				<compiler language="vb;vbs;visualbasic;vbscript" extension=".vb"
				type="Microsoft.CodeDom.Providers.DotNetCompilerPlatform.VBCodeProvider, Microsoft.CodeDom.Providers.DotNetCompilerPlatform, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
				warningLevel="4" compilerOptions="/langversion:14 /nowarn:41008 /define:_MYTYPE=\&quot;Web\&quot; /optionInfer+"/>
			</compilers>
		</system.codedom>


=============================================================
====	Validation
=============================================================

based on System.Componentmodel.DataAnnotations

MaxLength used by EF
ManLenght/MinLength no client side (use stringlength)

can have serviceproviders, and context items, but these not supported in MVC

can implement IValidateObject

MVC will addtionally validate based on data type

[Required] are fired first, validators should return valid for null data

validators should throw exceptions if datatypes wrong

validators should use newer "IsValid(object value, ValidationContext validationContext)"

validators should use two parameter ValidationResult(message,new string[]{validationContext.MemberName})

validators should use validationContext.DisplayName

[Display] (more options)
[Range]
[RegularExpression]
[Remote]

[DisplayName]? MVC 3?
[DisplayFormat]
[ScaffoldColumn]

[MetadataType]

IClientValidatable

=============================================================
====	Forms Authentication & MVC
=============================================================

When using MVC (and ASP.NET routes), we don't use the UrlAuthorizationModule.

Instead, we use the MVC [Authorize] attribute, which is an "authorization filter" that sends
back a 401 if the user is not authorized.

Before MVC3, it was difficult to secure all of your controllers. The solution was usually
to create a base controller with the attribute applied. In MVC3 global action filters were
introduced.

In MVC4, the [AllowAnonymous] was introduced, which works with the [Authorize] attribute
to allow anonymous access to login actions.

You can create custom authorization attributes and apply them globally, controller-level, or
on an action.

MVC5, introduces "Authentication Filters" which run before action filters, and allow you 
to change the principal via filter, and redirect to a login page via a challenge method. 
Presumably you could replace Forms Authentication with one of these.


=============================================================
====	Forms Authentication & Ajax
=============================================================

if (401) reload()

302

HttpResponse.SuppressFormsAuthenticationRedirect

Request.IsAjaxRequest
X-Requested-With: XMLHttpRequest


=============================================================
====	XSS & MVC
=============================================================


[AllowHtml] or [ValidateInput(false)]
Html.Raw is used. Html.AntiForgeryToken()
AntiXSS NuGet (if you need to accept HTML from users)

=============================================================
====	Threading
=============================================================

agile threads

when can a thread switch?
	anytime?
	between events?
	after application_beginrequest?
	after handler ctor?
	async handlers or modules?

seems sets culture and iprinciple are copied during threadswitch but not TLS




